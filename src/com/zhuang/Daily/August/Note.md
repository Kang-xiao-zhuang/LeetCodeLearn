开始补做2020.3月份开始的力扣每日一题，争取每个月都拿勋章，注意，要讲究融会贯通，效率之上💪💪💪

# 2020.3

1. [225. 用队列实现栈 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/implement-stack-using-queues/)
2. [206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/reverse-linked-list/)
3. [面试题 10.01. 合并排序的数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sorted-merge-lcci/)
4. [994. 腐烂的橘子 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rotting-oranges/)
5. [1103. 分糖果 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/distribute-candies-to-people/)
6. [剑指 Offer 57 - II. 和为s的连续正数序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)
7. [剑指 Offer 59 - II. 队列的最大值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)
8. [322. 零钱兑换 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/coin-change/)
9. [121. 买卖股票的最佳时机 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
10. [543. 二叉树的直径 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/diameter-of-binary-tree/)
11. [1013. 将数组分成和相等的三个部分 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/)
12. [1071. 字符串的最大公因子 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/)
13. [169. 多数元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/majority-element/)
14. [300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
15. [695. 岛屿的最大面积 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/max-area-of-island/)
16. [面试题 01.06. 字符串压缩 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/compress-string-lcci/)
17. [1160. 拼写单词 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)
18. [836. 矩形重叠 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rectangle-overlap/)
19. [409. 最长回文串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-palindrome/)
20. [剑指 Offer 40. 最小的k个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
21. [365. 水壶问题 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/water-and-jug-problem/)
22. [945. 使数组唯一的最小增量 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)
23. [876. 链表的中间结点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
24. [面试题 17.16. 按摩师 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/the-masseuse-lcci/)
25. [892. 三维形体的表面积 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/surface-area-of-3d-shapes/)
26. [999. 可以被一步捕获的棋子数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/available-captures-for-rook/)
27. [914. 卡牌分组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)
28. [820. 单词的压缩编码 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/short-encoding-of-words/)
29. [1162. 地图分析 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)
30. [剑指 Offer 62. 圆圈中最后剩下的数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)
31. [912. 排序数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sort-an-array/)



# 2020.4

1. [1111. 有效括号的嵌套深度 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)
2. [289. 生命游戏 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/game-of-life/)
3. [8. 字符串转换整数 (atoi) - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/string-to-integer-atoi/)
4. [42. 接雨水 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/trapping-rain-water/)
5. [460. LFU 缓存 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lfu-cache/)
6. [72. 编辑距离 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/edit-distance/)
7. [面试题 01.07. 旋转矩阵 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rotate-matrix-lcci/)
8. [剑指 Offer 13. 机器人的运动范围 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
9. [22. 括号生成 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/generate-parentheses/)
10. [151. 翻转字符串里的单词 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/reverse-words-in-a-string/)
11. [887. 鸡蛋掉落 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/super-egg-drop/)
12. [面试题 16.03. 交点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/intersection-lcci/)
13. [355. 设计推特 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/design-twitter/)
14. [445. 两数相加 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/add-two-numbers-ii/)
15. [542. 01 矩阵 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/01-matrix/)
16. [56. 合并区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/merge-intervals/)
17. [55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/jump-game/)
18. [11. 盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/container-with-most-water/)
19. [466. 统计重复个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/count-the-repetitions/)
20. [200. 岛屿数量 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-islands/)
21. [1248. 统计「优美子数组」 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)
22. [199. 二叉树的右视图 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
23. [面试题 08.11. 硬币 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/coin-lcci/)
24. [剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)
25. [46. 全排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutations/)
26. [23. 合并K个升序链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
27. [33. 搜索旋转排序数组 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
28. [剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)
29. [1095. 山脉数组中查找目标值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-in-mountain-array/)
30. [202. 快乐数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/happy-number/)





# 已完成

[551. 学生出勤记录 I - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/student-attendance-record-i/)

[![fhRptg.png](https://z3.ax1x.com/2021/08/17/fhRptg.png)](https://imgtu.com/i/fhRptg)

- 一次for遍历

```java
class Solution {
    public boolean checkRecord(String s) {
        int absent = 0, late = 0;
        int len = s.length();
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c == 'A') {
                absent++;
                if (absent >= 2) {
                    return false;
                }
            }
            if (c == 'L') {
                late++;
                if (late >= 3) {
                    return false;
                }
            } else {
                late = 0;
            }
        }
        System.out.println(true);
        return true;
    }
}
```
[345. 反转字符串中的元音字母 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

[![f7HVeK.png](https://z3.ax1x.com/2021/08/19/f7HVeK.png)](https://imgtu.com/i/f7HVeK)
```java
class Solution {
    public String reverseVowels(String s) {
        int left = 0;
        int right = s.length() - 1;

        char[] chars = s.toCharArray();
        while (left < right) {
            if (isVowel(chars[left]) && isVowel(chars[right])) {
                char temp = chars[left];
                chars[left] = chars[right];
                chars[right] = temp;
                left++;
                right--;
            }
                if (!isVowel(chars[left])) {
                    left++;
                }
                if (!isVowel(chars[right])) {
                    right--;
                }
            }
        return new String(chars);
    }
    public static boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
         || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
}
```
[541. 反转字符串 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/reverse-string-ii/)

[![fOerM4.png](https://z3.ax1x.com/2021/08/20/fOerM4.png)](https://imgtu.com/i/fOerM4)
```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] arr = s.toCharArray();
        int n = s.length();
        //每次前进2k，但是只交换前k个字符
        for (int i = 0; i < n; i += 2 * k) {
            reverse(arr, i, Math.min(i + k, n) - 1);
        }
        return new String(arr);
    }

    /**
     * 辅助函数 反转字符串
     *
     * @param arr   数组
     * @param left  左指针
     * @param right 右指针
     */
    public void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
             /*
            arr[left]^=arr[right];
            arr[right]^=arr[left];
            arr[left]^=arr[right];
            */
            left++;
            right--;
        }
    }
}
```
[443. 压缩字符串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/string-compression/)

![](https://pic.imgdb.cn/item/612069cc4907e2d39cf2b8ed.jpg)
```java
class Solution {
    public int compress(char[] chars) {
       int n = chars.length;
        int i = 0, j = 0;
        while (i < n) {
            int index = i;
            while (index < n && chars[index] == chars[i]) {
                index++;
            }
            int distance = index - i;
            // 指定插入的位置
            chars[j++] = chars[i];
            if (distance > 1) {
                int start = j;
                int end = start;
                while (distance != 0) {
                    chars[end++] = (char) ((distance % 10) + '0');
                    distance /= 10;
                }
                reverse(chars, start, end - 1);
                j = end;
            }
            i = index;
        }
        System.out.println(j);
        return j;
    }
    public static void reverse(char[] arr, int left, int right) {
        while (left < right) {
            
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
             /*
            arr[left] ^= arr[right];
            arr[right] ^= arr[left];
            arr[left] ^= arr[right];
            */
            left++;
            right--;
        }
    }
}
```
[789. 逃脱阻碍者 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/escape-the-ghosts/)

![](https://pic.imgdb.cn/item/61220c6b4907e2d39cb16790.jpg)
```java
class Solution {
    public boolean escapeGhosts(int[][] ghosts, int[] target) {
        // 计算出人走的距离
        int human_path = Math.abs(target[0]) + Math.abs(target[1]);
        // 有几个鬼 那就遍历几次
        for (int i = 0; i < ghosts.length; i++) {
            // 鬼走的距离，通过曼哈顿距离来求出  distance=|x1,x2|+|y1-y2|
            int ghost_path = Math.abs(ghosts[i][0] - target[0]) + Math.abs(ghosts[i][1] - target[1]);
            // 两个距离比较，人距离小，成功，否则GG
            if (human_path >= ghost_path) {
                return false;
            }
        }
        return true;
    }
}
```
[1646. 获取生成数组中的最大值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/get-maximum-in-generated-array/)

[![h9DOG4.png](https://z3.ax1x.com/2021/08/23/h9DOG4.png)](https://imgtu.com/i/h9DOG4)
```java
class Solution {
    public int getMaximumGenerated(int n) {
        if (n == 0) {
            return 0;
        }
        int[] nums = new int[n + 1];
        nums[0] = 0;
        nums[1] = 1;
        for (int i = 0; i < n; i++) {
            if (2 * i <= n) {
                nums[2 * i] = nums[i];
            }
            if (2 * i + 1 <= n) {
                nums[2 * i + 1] = nums[i] + nums[i + 1];
            }
        }
        int res = 0;
        for (int num : nums) {
            res = Math.max(res, num);
        }
        return res;
    }
}
```
# 未完成
[552. 学生出勤记录 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/student-attendance-record-ii/)

[![fTmlsx.png](https://z3.ax1x.com/2021/08/18/fTmlsx.png)](https://imgtu.com/i/fTmlsx)
```java
class Solution {
    int MOD = 1000000007;

    public int checkRecord(int n) {
        long[][] dp = new long[2][6];
        // 初始值
        dp[0][0] = 1;
        dp[0][1] = 1;
        dp[0][3] = 1;

        for (int i = 1; i < n; i++) {
            // 当前使用的下标
            int cur = i & 1;
            // 上一次使用的下标
            int last = (i - 1) & 1;
            dp[cur][0] = (dp[last][0] + dp[last][1] + dp[last][2]) % MOD;
            dp[cur][1] = dp[last][0];
            dp[cur][2] = dp[last][1];
            dp[cur][3] = (dp[last][3] + dp[last][4] + dp[last][5] + dp[last][0] + dp[last][1] + dp[last][2]) % MOD;
            dp[cur][4] = dp[last][3];
            dp[cur][5] = dp[last][4];
        }

        return (int) (LongStream.of(dp[(n - 1) & 1]).sum() % MOD);
    }
}
```
[787. K 站中转内最便宜的航班 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

[![hioABV.png](https://z3.ax1x.com/2021/08/24/hioABV.png)](https://imgtu.com/i/hioABV)
```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        final int INF = 10000 * 101 + 1;
        int[][] f = new int[k + 2][n];
        for (int i = 0; i < k + 2; ++i) {
            Arrays.fill(f[i], INF);
        }
        f[0][src] = 0;
        for (int t = 1; t <= k + 1; ++t) {
            for (int[] flight : flights) {
                int j = flight[0], i = flight[1], cost = flight[2];
                f[t][i] = Math.min(f[t][i], f[t - 1][j] + cost);
            }
        }
        int ans = INF;
        for (int t = 1; t <= k + 1; ++t) {
            ans = Math.min(ans, f[t][dst]);
        }
        return ans == INF ? -1 : ans;
    }
}
```
[797. 所有可能的路径 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

[![hVi8IK.png](https://z3.ax1x.com/2021/08/25/hVi8IK.png)](https://imgtu.com/i/hVi8IK)
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    Deque<Integer> stack = new ArrayDeque<Integer>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        stack.offerLast(0);
        dfs(graph, 0, graph.length - 1);
        return ans;
    }

    public void dfs(int[][] graph, int x, int n) {
        if (x == n) {
            ans.add(new ArrayList<Integer>(stack));
            return;
        }
        for (int y : graph[x]) {
            stack.offerLast(y);
            dfs(graph, y, n);
            stack.pollLast();
        }
    }
}
```